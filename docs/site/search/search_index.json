{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"cpp/","title":"C++","text":"<pre><code>template &lt;std::unsigned_integral UINT = DOWNSTREAM_UINT&gt;\nUINT _assign_storage_site(const UINT S, const UINT T);\n</code></pre> <pre><code>template &lt;std::unsigned_integral UINT = DOWNSTREAM_UINT&gt;\nstd::optional&lt;UINT&gt; assign_storage_site(const UINT S, const UINT T);\n</code></pre> <pre><code>template &lt;std::unsigned_integral UINT = DOWNSTREAM_UINT&gt;\nbool has_ingest_capacity(const UINT S, const UINT T);\n</code></pre> <pre><code>template &lt;std::unsigned_integral UINT = DOWNSTREAM_UINT&gt;\nUINT _assign_storage_site(const UINT S, const UINT T);\n</code></pre> <pre><code>template &lt;std::unsigned_integral UINT = DOWNSTREAM_UINT&gt;\nstd::optional&lt;UINT&gt; assign_storage_site(const UINT S, const UINT T);\n</code></pre> <pre><code>template &lt;std::unsigned_integral UINT = DOWNSTREAM_UINT&gt;\nbool has_ingest_capacity(const UINT S, const UINT T);\n</code></pre> <pre><code>template &lt;std::unsigned_integral UINT = DOWNSTREAM_UINT&gt;\nUINT _assign_storage_site(const UINT S, const UINT T);\n</code></pre> <pre><code>template &lt;std::unsigned_integral UINT = DOWNSTREAM_UINT&gt;\nstd::optional&lt;UINT&gt; assign_storage_site(const UINT S, const UINT T);\n</code></pre>"},{"location":"python/","title":"Documentation for <code>Python</code>","text":""},{"location":"python/#steady_algo._steady_assign_storage_site","title":"<code>steady_algo._steady_assign_storage_site</code>","text":""},{"location":"python/#steady_algo._steady_assign_storage_site.steady_assign_storage_site","title":"<code>steady_assign_storage_site(S, T)</code>","text":"<p>Site selection algorithm for steady curation.</p> <p>Parameters:</p> Name Type Description Default <code>S</code> <code>int</code> <p>Buffer size. Must be a power of two.</p> required <code>T</code> <code>int</code> <p>Current logical time.</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Selected site, if any.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If insufficient ingest capacity is available.</p> <p>See <code>steady_algo.has_ingest_capacity</code> for details.</p> Source code in <code>steady_algo/_steady_assign_storage_site.py</code> <pre><code>def steady_assign_storage_site(S: int, T: int) -&gt; typing.Optional[int]:\n    \"\"\"Site selection algorithm for steady curation.\n\n    Parameters\n    ----------\n    S : int\n        Buffer size. Must be a power of two.\n    T : int\n        Current logical time.\n\n    Returns\n    -------\n    typing.Optional[int]\n        Selected site, if any.\n\n    Raises\n    ------\n    ValueError\n        If insufficient ingest capacity is available.\n\n        See `steady_algo.has_ingest_capacity` for details.\n    \"\"\"\n    if not steady_has_ingest_capacity(S, T):\n        raise ValueError(f\"Insufficient ingest capacity for {S=}, {T=}\")\n\n    s = S.bit_length() - 1\n    t = T.bit_length() - s  # Current epoch (or negative)\n    h = ctz(T + 1)  # Current hanoi value\n    if h &lt; t:  # If not a top n(T) hanoi value...\n        return None  # ...discard without storing\n\n    i = T &gt;&gt; (h + 1)  # Hanoi value incidence (i.e., num seen)\n    if i == 0:  # Special case the 0th bunch\n        k_b = 0  # Bunch position\n        o = 0  # Within-bunch offset\n        w = s + 1  # Segment width\n    else:\n        j = bit_floor(i) - 1  # Num full-bunch segments\n        B = j.bit_length()  # Num full bunches\n        k_b = (1 &lt;&lt; B) * (s - B + 1)  # Bunch position\n        w = h - t + 1  # Segment width\n        assert w &gt; 0\n        o = w * (i - j - 1)  # Within-bunch offset\n\n    p = h % w  # Within-segment offset\n    return k_b + o + p  # Calculate placement site\n</code></pre>"},{"location":"python/#steady_algo._steady_assign_storage_site_batched","title":"<code>steady_algo._steady_assign_storage_site_batched</code>","text":""},{"location":"python/#steady_algo._steady_assign_storage_site_batched.steady_assign_storage_site_batched","title":"<code>steady_assign_storage_site_batched(S, T)</code>","text":"<p>Site selection algorithm for steady curation.</p> <p>Parameters:</p> Name Type Description Default <code>S</code> <code>Union[ndarray, int]</code> <p>Buffer size. Must be a power of two, &lt;= 2**52.</p> required <code>T</code> <code>Union[ndarray, int]</code> <p>Current logical time. Must be &lt;= 2**52.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Selected site, if any. Otherwise, S.</p> Source code in <code>steady_algo/_steady_assign_storage_site_batched.py</code> <pre><code>def steady_assign_storage_site_batched(\n    S: typing.Union[np.ndarray, int], T: typing.Union[np.ndarray, int]\n) -&gt; np.ndarray:\n    \"\"\"Site selection algorithm for steady curation.\n\n    Parameters\n    ----------\n    S : Union[np.ndarray, int]\n        Buffer size. Must be a power of two, &lt;= 2**52.\n    T : Union[np.ndarray, int]\n        Current logical time. Must be &lt;= 2**52.\n\n    Returns\n    -------\n    np.array\n        Selected site, if any. Otherwise, S.\n    \"\"\"\n    S, T = np.atleast_1d(S).astype(np.int64), np.atleast_1d(T).astype(np.int64)\n    assert np.logical_and(S &gt; 1, np.bitwise_count(S) == 1).all()\n    # restriction &lt;= 2 ** 52 might be overly conservative\n    assert (np.maximum(S, T) &lt;= 2**52).all()\n\n    s = bitlen32(S) - 1\n    t = bitlen32(T) - s  # Current epoch (or negative)\n    h = ctz32(T + 1)  # Current hanoi value\n\n    i = T &gt;&gt; (h + 1)  # Hanoi value incidence (i.e., num seen)\n\n    j = bit_floor32(i) - 1  # Num full-bunch segments\n    B = bitlen32(j)  # Num full bunches\n    k_b = (1 &lt;&lt; B) * (s - B + 1)  # Bunch position\n    w = h - t + 1  # Segment width\n    assert np.where((h &gt;= t) &amp; (i != 0), w &gt; 0, True).all()\n    o = w * (i - j - 1)  # Within-bunch offset\n\n    # Special case the 0th bunch...\n    zeroth_bunch = i == 0\n    k_b[zeroth_bunch] = 0\n    o[zeroth_bunch] = 0\n    w[zeroth_bunch] = np.broadcast_to(s, w.shape)[zeroth_bunch] + 1\n\n    with np.errstate(divide=\"ignore\"):\n        p = h % w  # Within-segment offset\n\n    # handle discard without storing for non-top n(T) hanoi value...\n    return np.where(h &gt;= t, k_b + o + p, S)\n</code></pre>"},{"location":"python/steady_algo/","title":"Documentation for <code>Python</code>","text":""},{"location":"python/steady_algo/#steady_algo._steady_assign_storage_site","title":"<code>steady_algo._steady_assign_storage_site</code>","text":""},{"location":"python/steady_algo/#steady_algo._steady_assign_storage_site.steady_assign_storage_site","title":"<code>steady_assign_storage_site(S, T)</code>","text":"<p>Site selection algorithm for steady curation.</p> <p>Parameters:</p> Name Type Description Default <code>S</code> <code>int</code> <p>Buffer size. Must be a power of two.</p> required <code>T</code> <code>int</code> <p>Current logical time.</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Selected site, if any.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If insufficient ingest capacity is available.</p> <p>See <code>steady_algo.has_ingest_capacity</code> for details.</p> Source code in <code>steady_algo/_steady_assign_storage_site.py</code> <pre><code>def steady_assign_storage_site(S: int, T: int) -&gt; typing.Optional[int]:\n    \"\"\"Site selection algorithm for steady curation.\n\n    Parameters\n    ----------\n    S : int\n        Buffer size. Must be a power of two.\n    T : int\n        Current logical time.\n\n    Returns\n    -------\n    typing.Optional[int]\n        Selected site, if any.\n\n    Raises\n    ------\n    ValueError\n        If insufficient ingest capacity is available.\n\n        See `steady_algo.has_ingest_capacity` for details.\n    \"\"\"\n    if not steady_has_ingest_capacity(S, T):\n        raise ValueError(f\"Insufficient ingest capacity for {S=}, {T=}\")\n\n    s = S.bit_length() - 1\n    t = T.bit_length() - s  # Current epoch (or negative)\n    h = ctz(T + 1)  # Current hanoi value\n    if h &lt; t:  # If not a top n(T) hanoi value...\n        return None  # ...discard without storing\n\n    i = T &gt;&gt; (h + 1)  # Hanoi value incidence (i.e., num seen)\n    if i == 0:  # Special case the 0th bunch\n        k_b = 0  # Bunch position\n        o = 0  # Within-bunch offset\n        w = s + 1  # Segment width\n    else:\n        j = bit_floor(i) - 1  # Num full-bunch segments\n        B = j.bit_length()  # Num full bunches\n        k_b = (1 &lt;&lt; B) * (s - B + 1)  # Bunch position\n        w = h - t + 1  # Segment width\n        assert w &gt; 0\n        o = w * (i - j - 1)  # Within-bunch offset\n\n    p = h % w  # Within-segment offset\n    return k_b + o + p  # Calculate placement site\n</code></pre>"},{"location":"python/steady_algo/#steady_algo._steady_assign_storage_site_batched","title":"<code>steady_algo._steady_assign_storage_site_batched</code>","text":""},{"location":"python/steady_algo/#steady_algo._steady_assign_storage_site_batched.steady_assign_storage_site_batched","title":"<code>steady_assign_storage_site_batched(S, T)</code>","text":"<p>Site selection algorithm for steady curation.</p> <p>Parameters:</p> Name Type Description Default <code>S</code> <code>Union[ndarray, int]</code> <p>Buffer size. Must be a power of two, &lt;= 2**52.</p> required <code>T</code> <code>Union[ndarray, int]</code> <p>Current logical time. Must be &lt;= 2**52.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Selected site, if any. Otherwise, S.</p> Source code in <code>steady_algo/_steady_assign_storage_site_batched.py</code> <pre><code>def steady_assign_storage_site_batched(\n    S: typing.Union[np.ndarray, int], T: typing.Union[np.ndarray, int]\n) -&gt; np.ndarray:\n    \"\"\"Site selection algorithm for steady curation.\n\n    Parameters\n    ----------\n    S : Union[np.ndarray, int]\n        Buffer size. Must be a power of two, &lt;= 2**52.\n    T : Union[np.ndarray, int]\n        Current logical time. Must be &lt;= 2**52.\n\n    Returns\n    -------\n    np.array\n        Selected site, if any. Otherwise, S.\n    \"\"\"\n    S, T = np.atleast_1d(S).astype(np.int64), np.atleast_1d(T).astype(np.int64)\n    assert np.logical_and(S &gt; 1, np.bitwise_count(S) == 1).all()\n    # restriction &lt;= 2 ** 52 might be overly conservative\n    assert (np.maximum(S, T) &lt;= 2**52).all()\n\n    s = bitlen32(S) - 1\n    t = bitlen32(T) - s  # Current epoch (or negative)\n    h = ctz32(T + 1)  # Current hanoi value\n\n    i = T &gt;&gt; (h + 1)  # Hanoi value incidence (i.e., num seen)\n\n    j = bit_floor32(i) - 1  # Num full-bunch segments\n    B = bitlen32(j)  # Num full bunches\n    k_b = (1 &lt;&lt; B) * (s - B + 1)  # Bunch position\n    w = h - t + 1  # Segment width\n    assert np.where((h &gt;= t) &amp; (i != 0), w &gt; 0, True).all()\n    o = w * (i - j - 1)  # Within-bunch offset\n\n    # Special case the 0th bunch...\n    zeroth_bunch = i == 0\n    k_b[zeroth_bunch] = 0\n    o[zeroth_bunch] = 0\n    w[zeroth_bunch] = np.broadcast_to(s, w.shape)[zeroth_bunch] + 1\n\n    with np.errstate(divide=\"ignore\"):\n        p = h % w  # Within-segment offset\n\n    # handle discard without storing for non-top n(T) hanoi value...\n    return np.where(h &gt;= t, k_b + o + p, S)\n</code></pre>"}]}