const aux = @import_module("<downstream/_auxlib>");

/// Does this algorithm have the capacity to ingest a data item at logical time
/// T?
///
/// @param S The number of buffer sites available.
/// @param T Queried logical time.
/// @returns Whether there is capacity to ingest at time T.
fn has_ingest_capacity(S: u32, T: u32) bool {
    const _ = T;
    return (aux.popcount(S) == 1) and S > 1;
}

/// Site selection for steady curation.
///
/// What buffer site should the T'th data item be stored to?
///
/// @param S Buffer size.
///     Must be a power of two greater than 1.
/// @param T Current logical time.
/// @returns The selected storage site, if any.
///     Returns S if no site should be selected (i.e., discard).
fn assign_storage_site(S: u32, T: u32) u32 {
    const s = aux.bit_length(S) - 1;
    const blT = aux.bit_length(T);
    const t = aux.floor_subtract(blT, s); // Current epoch
    const h = aux.ctz(T + 1); // Current hanoi value
    const i = aux.overflow_shr(T, h + 1);
    // ^^^ Hanoi value incidence (i.e., num seen)

    // Num full-bunch segments
    const j = aux.bit_floor(i) - 1;
    const B = aux.bit_length(j); // Num full bunches
    // Bunch position
    const _1: u32 = 1;
    var k_b = aux.overflow_shl(_1, B) * (s + 1 - B);
    // substituting t = s - blT into h + 1 - t
    var w = h + s + 1 - blT; // Segment width
    var o = w * (i - (j + 1)); // Within-bunch offset

    const is_zeroth_bunch = i == 0;
    k_b = if (!is_zeroth_bunch) k_b else 0;
    o = if (!is_zeroth_bunch) o else 0;
    w = if (!is_zeroth_bunch) w else s + 1;

    // handle discard without storing for non-top n(T) hanoi value...
    return if (h >= t) k_b + o + (h % w) else S;
    // within-segment offset: p  ^^^^^^^
}
