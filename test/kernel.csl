param memcpy_params: comptime_struct;
param chunkSize: i32;
param peId: i16;

const memcpy = @import_module("<memcpy/memcpy>", memcpy_params);
const math = @import_module("<math>");

const dstream = @import_module("<downstream/dstream/main>");

var cases = @zeros([chunkSize * 2]u32);
var ptr_cases : [*]u32 = &cases;

var results = @zeros([chunkSize]u32);
var ptr_results : [*]u32 = &results;

fn launch_circular_algo_assign_storage_site() void {
  for(@range(u32, chunkSize)) |case| {
    const S = cases[2*case];
    const T = cases[2*case + 1];
    const has_capacity = dstream.circular_algo.has_ingest_capacity(S, T);
    results[case] = (
      if (has_capacity) dstream.circular_algo.assign_storage_site(S, T)
      else S + 1
    );
  }
  memcpy.unblock_cmd_stream();
}

fn launch_hybrid_0_steady_1_circular_2_algo_assign_storage_site() void {
  for(@range(u32, chunkSize)) |case| {
    const S = cases[2*case];
    const T = cases[2*case + 1];
    const has_capacity = dstream.hybrid_0_steady_1_circular_2_algo.has_ingest_capacity(S, T);
    results[case] = (
      if (has_capacity) dstream.hybrid_0_steady_1_circular_2_algo.assign_storage_site(S, T)
      else S + 1
    );
  }
  memcpy.unblock_cmd_stream();
}

fn launch_hybrid_0_steady_1_stretched_2_algo_assign_storage_site() void {
  for(@range(u32, chunkSize)) |case| {
    const S = cases[2*case];
    const T = cases[2*case + 1];
    const has_capacity = dstream.hybrid_0_steady_1_stretched_2_algo.has_ingest_capacity(S, T);
    results[case] = (
      if (has_capacity) dstream.hybrid_0_steady_1_stretched_2_algo.assign_storage_site(S, T)
      else S + 1
    );
  }
  memcpy.unblock_cmd_stream();
}

fn launch_hybrid_0_steady_1_tilted_2_algo_assign_storage_site() void {
  for(@range(u32, chunkSize)) |case| {
    const S = cases[2*case];
    const T = cases[2*case + 1];
    const has_capacity = dstream.hybrid_0_steady_1_tilted_2_algo.has_ingest_capacity(S, T);
    results[case] = (
      if (has_capacity) dstream.hybrid_0_steady_1_tilted_2_algo.assign_storage_site(S, T)
      else S + 1
    );
  }
  memcpy.unblock_cmd_stream();
}

fn launch_steady_algo_assign_storage_site() void {
  for(@range(u32, chunkSize)) |case| {
    const S = cases[2*case];
    const T = cases[2*case + 1];
    const has_capacity = dstream.steady_algo.has_ingest_capacity(S, T);
    results[case] = (
      if (has_capacity) dstream.steady_algo.assign_storage_site(S, T)
      else S + 1
    );
  }
  memcpy.unblock_cmd_stream();
}

fn launch_stretched_algo_assign_storage_site() void {
  for(@range(u32, chunkSize)) |case| {
    const S = cases[2*case];
    const T = cases[2*case + 1];
    const has_capacity = dstream.stretched_algo.has_ingest_capacity(S, T);
    results[case] = (
      if (has_capacity) dstream.stretched_algo.assign_storage_site(S, T)
      else S + 1
    );
  }
  memcpy.unblock_cmd_stream();
}

fn launch_tilted_algo_assign_storage_site() void {
  for(@range(u32, chunkSize)) |case| {
    const S = cases[2*case];
    const T = cases[2*case + 1];
    const has_capacity = dstream.tilted_algo.has_ingest_capacity(S, T);
    results[case] = (
      if (has_capacity) dstream.tilted_algo.assign_storage_site(S, T)
      else S + 1
    );
  }
  memcpy.unblock_cmd_stream();
}

const in_q_lauch : input_queue = @get_input_queue(2);  // RE: non-wse2 only
const launch_task_id : data_task_id = (
  if (@is_arch("wse2")) @get_data_task_id(memcpy.LAUNCH)
  else @get_data_task_id(in_q_lauch)
);

comptime {
  @export_symbol(ptr_cases, "cases");
  @export_symbol(ptr_results, "results");
  @export_symbol(launch_hybrid_0_steady_1_stretched_2_algo_assign_storage_site);
  @export_symbol(launch_hybrid_0_steady_1_tilted_2_algo_assign_storage_site);
  @export_symbol(launch_steady_algo_assign_storage_site);
  @export_symbol(launch_stretched_algo_assign_storage_site);
  @export_symbol(launch_tilted_algo_assign_storage_site);
  @rpc(launch_task_id);
  if (!@is_arch("wse2")) {
    @initialize_queue(in_q_lauch, .{ .color = memcpy.LAUNCH });
  }
}
